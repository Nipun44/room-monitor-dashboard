<!DOCTYPE html>
<html>
<head>
  <title>Room Monitor Dashboard</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Roboto', sans-serif; 
      text-align: center; 
      padding: 20px; 
      background-color: #0a0a23; /* Dark background */
      color: #f0f0f0; /* Light grey text */
    }
    h1 { 
      font-family: 'Orbitron', sans-serif;
      font-size: 28px; /* Slightly larger */
      margin-bottom: 25px; 
      color: #00d0ff; /* Bright blue neon-like color */
      text-shadow: 0 0 5px #00d0ff, 0 0 10px #00d0ff, 0 0 15px #00d0ff; /* Neon glow effect */
    }
    .values {
      font-size: 22px; /* Slightly larger for prominence */
      margin-bottom: 20px;
      color: #e0e0e0; /* Lighter color for labels */
    }
    .values span { /* Targets <span> elements within .values for actual data */
      color: #ffffff; /* White for actual data */
      font-weight: bold;
    }
    /* Timestamp styling - label and value */
    #time-label {
        color: #b0b0b0; /* Softer grey for "Timestamp:" label part */
    }
    #time-value {
        color: #ffffff; /* White for actual data */
        font-weight: bold;
    }
    .charts-container {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    .chart-wrapper {
      max-width: 400px;
      width: 100%;
      background-color: #1c1c3c; /* Darker shade for chart background */
      padding: 15px;
      border-radius: 8px; /* Rounded corners */
      border: 1px solid #00d0ff; /* Subtle border with accent color */
      box-shadow: 0 0 10px rgba(0, 208, 255, 0.3); /* Subtle glow for chart wrappers */
      transition: all 0.3s ease-in-out; /* Smooth transition for hover effects */
    }
    .chart-wrapper:hover {
      box-shadow: 0 0 15px rgba(0, 208, 255, 0.5); /* Enhanced glow on hover */
      transform: scale(1.02); /* Slightly scale up on hover */
    }
    .chart-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      margin-bottom: 10px; /* Increased margin */
      font-size: 20px; /* Larger chart title */
      color: #00d0ff; /* Accent color for chart titles */
    }
    /* Ensure Chart.js canvas elements are not affected by general canvas styling for 3D scene if any */
    .chart-wrapper canvas {
      max-height: 200px !important;
      height: 200px !important;
      width: 100% !important;
      border-radius: 4px; /* Slightly rounded corners for canvas */
    }
    #time-container { /* Container for timestamp label and value */
      font-size: 18px; /* Larger timestamp */
      margin-bottom: 30px;
      display: block;
    }

    /* 3D Scene Container Styles */
    #scene-3d-container {
      width: 80%; 
      max-width: 600px;
      height: 400px; 
      margin: 20px auto;
      border: 1px solid #00d0ff; 
      border-radius: 8px;
      position: relative; 
      background-color: #000000; /* Fallback if canvas doesn't load */
      overflow: hidden; /* Ensures Three.js canvas fits rounded corners */
    }
    #scene-3d-container canvas { /* Style for the Three.js canvas itself */
        display: block; /* Removes any potential extra space below canvas */
    }
  </style>
</head>
<body>
  <h1>üìä Room Monitor</h1>

  <div id="scene-3d-container"></div>

  <div class="values">
    üå° Temperature: <span id="temp">--</span> ¬∞C &nbsp;&nbsp; | &nbsp;&nbsp; üíß Humidity: <span id="hum">--</span> %
  </div>
  <div id="time-container"><span id="time-label">‚è± Timestamp: </span><span id="time-value">--</span></div>

  <div class="charts-container">
    <div class="chart-wrapper">
      <div class="chart-title">Temperature (¬∞C)</div>
      <canvas id="tempChart"></canvas>
    </div>
    <div class="chart-wrapper">
      <div class="chart-title">Humidity (%)</div>
      <canvas id="humChart"></canvas>
    </div>
  </div>

  <script>
    // Firebase and Chart.js setup
    const firebaseConfig = {
      apiKey: "AIzaSyCHCmEo57ty3kLvZRay6BJ8Ie2PjSTnPDg",
      authDomain: "iot-project-baw-pal.firebaseapp.com",
      databaseURL: "https://iot-project-baw-pal-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iot-project-baw-pal",
      storageBucket: "iot-project-baw-pal.firebasestorage.app",
      messagingSenderId: "845069079178",
      appId: "1:845069079178:web:b877db653292ec2eb79373",
      measurementId: "G-THREY0M483"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tempData = [];
    let humData = [];
    let labels = [];

    function formatTimestamp(ts) {
      if (!ts) return '--'; 
      return ts.substr(0, 10) + ' ' + ts.substr(11, 8);
    }

    function updateLatest(data) {
      document.getElementById("temp").textContent = data.temperature.toFixed(2);
      document.getElementById("hum").textContent = data.humidity.toFixed(2);
      document.getElementById("time-value").textContent = formatTimestamp(data.timestamp); 
    }

    const ctxTemp = document.getElementById('tempChart').getContext('2d');
    const ctxHum = document.getElementById('humChart').getContext('2d');

    const commonOptions = {
      responsive: true, animation: false,
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45, autoSkip: true, maxTicksLimit: 10, color: '#f0f0f0' }, grid: { color: 'rgba(240, 240, 240, 0.1)' } },
        y: { beginAtZero: false, ticks: { color: '#f0f0f0' }, grid: { color: 'rgba(240, 240, 240, 0.1)' } }
      },
      plugins: { legend: { display: false, labels: { color: '#f0f0f0' } }, tooltip: { mode: 'index', intersect: false, backgroundColor: 'rgba(0, 0, 0, 0.7)', titleColor: '#00d0ff', bodyColor: '#f0f0f0', borderColor: '#00d0ff', borderWidth: 1 } }
    };

    const tempChart = new Chart(ctxTemp, { type: 'line', data: { labels: labels, datasets: [{ label: 'Temperature (¬∞C)', data: tempData, borderColor: '#39ff14', backgroundColor: 'rgba(57, 255, 20, 0.25)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 }] }, options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, suggestedMin: 15, suggestedMax: 40 } } } });
    const humChart = new Chart(ctxHum, { type: 'line', data: { labels: labels, datasets: [{ label: 'Humidity (%)', data: humData, borderColor: '#ff00ff', backgroundColor: 'rgba(255, 0, 255, 0.25)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 }] }, options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, suggestedMin: 20, suggestedMax: 80 } } } });

    // Three.js Scene Setup
    let scene, camera, renderer, requestID;
    let sun3D, moon3D, field3D, tree3DGroup, bird3D, starField, dog3D; 
    let cone3Geometry; 

    function updateSunMoonVisibility(timestamp) {
      let hour;
      if (timestamp) {
        const timePart = timestamp.includes('T') ? timestamp.split('T')[1] : timestamp.split(' ')[1];
        if (timePart) { hour = parseInt(timePart.substr(0, 2)); } else { hour = new Date().getHours(); }
      } else { hour = new Date().getHours(); }

      if (sun3D && moon3D) {
        if (hour >= 6 && hour < 18) { sun3D.visible = true; moon3D.visible = false; } 
        else { sun3D.visible = false; moon3D.visible = true; }
      }
    }

    function updateBirdState(temperature, humidity, isDaytime) { 
      if (!bird3D || !bird3D.userData.originalMaterial || !tree3DGroup || !cone3Geometry) {
        return;
      }
      bird3D.visible = true; 
      const birdBodyMesh = bird3D.getObjectByName("birdBody");
      if (!birdBodyMesh) return; 

      if (isDaytime) {
        bird3D.position.set(0, 1, -1); 
        bird3D.rotation.set(0, 0, 0); 
      } else { 
        const birdBodyRadius = birdBodyMesh.geometry.parameters.radius || 0.2;
        const cone3Mesh = tree3DGroup.children.find(child => child.geometry === cone3Geometry); 
        if (cone3Mesh) {
            const pineTopY = tree3DGroup.position.y + cone3Mesh.position.y + (cone3Mesh.geometry.parameters.height / 2);
            bird3D.position.set(
              tree3DGroup.position.x, 
              pineTopY + birdBodyRadius, 
              tree3DGroup.position.z
            );
        } else { 
            bird3D.position.set(tree3DGroup.position.x, tree3DGroup.position.y + 1.6 + 0.3 + birdBodyRadius, tree3DGroup.position.z);
        }
      }

      if (temperature > 28) { 
        birdBodyMesh.material.color.setHex(0x333333); 
        birdBodyMesh.material.metalness = 0.7; 
        birdBodyMesh.material.roughness = 0.3; 
      } else { 
        birdBodyMesh.material.color.setHex(bird3D.userData.originalMaterial.color);
        birdBodyMesh.material.metalness = bird3D.userData.originalMaterial.metalness;
        birdBodyMesh.material.roughness = bird3D.userData.originalMaterial.roughness;
      }
    }

    function updateDogState(temperature) {
      if (!dog3D || !dog3D.userData.originalMaterialColor) return;
      const dogBodyMesh = dog3D.getObjectByName("dogBody");
      if (!dogBodyMesh) return;

      if (temperature > 28) { // Hot condition
        dogBodyMesh.material.color.setHex(0xFF0000); // Change to Red
      } else { // Normal condition
        dogBodyMesh.material.color.setHex(dog3D.userData.originalMaterialColor);
      }
    }

    function initThreeJS() {
      const container = document.getElementById('scene-3d-container');
      if (!container) { console.error("3D scene container not found!"); return; }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); 
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      camera = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5); 
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(containerWidth, containerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement); 
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); 
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);
      
      // Sun Model - Updated Size & Position
      const sunGeometry = new THREE.SphereGeometry(1.25, 32, 32); // Radius 0.5 * 2.5 = 1.25
      const sunMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd00, emissive: 0xffdd00, emissiveIntensity: 1 });
      sun3D = new THREE.Mesh(sunGeometry, sunMaterial);
      sun3D.position.set(-5, 4, -6); // New position
      scene.add(sun3D);

      // Moon Model - Updated Size & Position
      const moonGeometry = new THREE.SphereGeometry(0.75, 32, 32); // Radius 0.3 * 2.5 = 0.75
      const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      moon3D = new THREE.Mesh(moonGeometry, moonMaterial);
      moon3D.position.set(5, 4, -6); // New position
      scene.add(moon3D);

      const fieldGeometry = new THREE.PlaneGeometry(10, 10);
      const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
      field3D = new THREE.Mesh(fieldGeometry, fieldMaterial);
      field3D.rotation.x = -Math.PI / 2; 
      field3D.position.y = -1; 
      scene.add(field3D);

      tree3DGroup = new THREE.Group();
      const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 16); 
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk3D = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk3D.position.y = 0; 
      tree3DGroup.add(trunk3D);
      const pineLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x004d00 }); 
      const cone1Geometry = new THREE.ConeGeometry(0.6, 1.0, 16);
      const cone1 = new THREE.Mesh(cone1Geometry, pineLeavesMaterial);
      cone1.position.y = 0.5 + (1.0 / 2); 
      tree3DGroup.add(cone1);
      const cone2Geometry = new THREE.ConeGeometry(0.45, 0.8, 16);
      const cone2 = new THREE.Mesh(cone2Geometry, pineLeavesMaterial);
      cone2.position.y = cone1.position.y + (1.0 / 2) - 0.2; 
      tree3DGroup.add(cone2);
      cone3Geometry = new THREE.ConeGeometry(0.3, 0.6, 16);
      const cone3 = new THREE.Mesh(cone3Geometry, pineLeavesMaterial);
      cone3.position.y = cone2.position.y + (0.8 / 2) - 0.1; 
      tree3DGroup.add(cone3);
      tree3DGroup.position.set(0, -1.0, 0); 
      scene.add(tree3DGroup);

      bird3D = new THREE.Group();
      const birdBodyGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const birdBodyMat = new THREE.MeshStandardMaterial({ color: 0x6495ED, metalness: 0.1, roughness: 0.8 });
      const birdBody = new THREE.Mesh(birdBodyGeom, birdBodyMat);
      birdBody.name = "birdBody"; 
      bird3D.add(birdBody);
      const birdHeadGeom = new THREE.SphereGeometry(0.12, 16, 16);
      const birdHead = new THREE.Mesh(birdHeadGeom, birdBodyMat.clone()); 
      birdHead.name = "birdHead"; 
      birdHead.position.set(0, 0.2, 0.05); 
      bird3D.add(birdHead);
      bird3D.userData.originalMaterial = {
          color: birdBodyMat.color.getHex(),
          metalness: birdBodyMat.metalness,
          roughness: birdBodyMat.roughness
      };
      bird3D.position.set(0, 1, -1); 
      bird3D.visible = false; 
      scene.add(bird3D); 

      dog3D = new THREE.Group();
      const dogBodyGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.5); 
      const dogBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); 
      const dogBody = new THREE.Mesh(dogBodyGeometry, dogBodyMaterial);
      dogBody.name = "dogBody";
      dog3D.add(dogBody);
      const dogHeadGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
      const dogHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); 
      const dogHead = new THREE.Mesh(dogHeadGeometry, dogHeadMaterial);
      dogHead.name = "dogHead";
      dogHead.position.set(0.5, 0.2, 0); 
      dog3D.add(dogHead);
      const legGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
      const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); 
      const leg1 = new THREE.Mesh(legGeometry, legMaterial); 
      leg1.position.set(0.3, -0.25, 0.15); 
      dog3D.add(leg1);
      const leg2 = new THREE.Mesh(legGeometry, legMaterial); 
      leg2.position.set(0.3, -0.25, -0.15);
      dog3D.add(leg2);
      const leg3 = new THREE.Mesh(legGeometry, legMaterial); 
      leg3.position.set(-0.3, -0.25, 0.15);
      dog3D.add(leg3);
      const leg4 = new THREE.Mesh(legGeometry, legMaterial); 
      leg4.position.set(-0.3, -0.25, -0.15);
      dog3D.add(leg4);
      dog3D.userData.originalMaterialColor = dogBodyMaterial.color.getHex();
      dog3D.position.set(-1.5, -0.6, 1); 
      scene.add(dog3D);

      // Starfield
      const starVertices = [];
      const minDistance = 50; 
      const starCount = 1000;
      for (let i = 0; i < starCount; i++) {
          let x, y, z, dist;
          do {
              x = THREE.MathUtils.randFloatSpread(200); 
              y = THREE.MathUtils.randFloatSpread(200);
              z = THREE.MathUtils.randFloatSpread(200);
              dist = Math.sqrt(x*x + y*y + z*z);
          } while (dist < minDistance);
          starVertices.push(x, y, z);
      }
      const starsGeometry = new THREE.BufferGeometry();
      starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const starsMaterial = new THREE.PointsMaterial({ 
          color: 0xffffff, size: 0.15, sizeAttenuation: true 
      });
      starField = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starField);

      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      requestID = requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('scene-3d-container');
      if (container && camera && renderer) { 
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    }

    function mainAppInit() {
        initThreeJS();
        if (scene && camera && renderer) { 
            animate(); 
            updateSunMoonVisibility(new Date().toISOString()); 
            const currentHour = new Date().getHours();
            const isDay = (currentHour >= 6 && currentHour < 18);
            updateBirdState(15, 50, isDay); 
            updateDogState(15); 
        }
    }

    if (document.readyState === 'loading') { 
        document.addEventListener('DOMContentLoaded', mainAppInit);
    } else { 
        mainAppInit(); 
    }

    const ref = db.ref("smarthome");
    ref.limitToLast(240).on("value", snapshot => {
      tempData = []; humData = []; labels = [];
      snapshot.forEach(childSnap => { const data = childSnap.val(); if (data.temperature != null && data.humidity != null && data.timestamp) { tempData.push(parseFloat(data.temperature)); humData.push(parseFloat(data.humidity)); labels.push(data.timestamp.substr(11, 5)); } });
      tempChart.data.labels = labels; tempChart.data.datasets[0].data = tempData; tempChart.update();
      humChart.data.labels = labels; humChart.data.datasets[0].data = humData; humChart.update();
      
      const last = snapshot.val() ? Object.values(snapshot.val()).pop() : null;
      if (last) { 
        updateLatest(last); 
        const currentTimestamp = last.timestamp ? last.timestamp : new Date().toISOString();
        updateSunMoonVisibility(currentTimestamp);

        let currentHourForBird;
        if (last.timestamp) {
            const timePart = last.timestamp.includes('T') ? last.timestamp.split('T')[1] : last.timestamp.split(' ')[1];
            if (timePart) currentHourForBird = parseInt(timePart.substr(0, 2));
            else currentHourForBird = new Date().getHours(); 
        } else {
            currentHourForBird = new Date().getHours(); 
        }
        const isDaytimeForBird = (currentHourForBird >= 6 && currentHourForBird < 18);
        
        const tempForBirdAndDog = (last.temperature != null) ? parseFloat(last.temperature) : 15; 
        const humForBird = (last.humidity != null) ? parseFloat(last.humidity) : 50; 

        if (!isNaN(tempForBirdAndDog) && !isNaN(humForBird)) {
            updateBirdState(tempForBirdAndDog, humForBird, isDaytimeForBird);
        }
        if (!isNaN(tempForBirdAndDog)) {
            updateDogState(tempForBirdAndDog);
        }

      } else { 
        document.getElementById("temp").textContent = '--'; 
        document.getElementById("hum").textContent = '--'; 
        document.getElementById("time-value").textContent = '--'; 
        
        const currentTimestamp = new Date().toISOString();
        updateSunMoonVisibility(currentTimestamp);
        
        const currentHour = new Date().getHours();
        const isDay = (currentHour >= 6 && currentHour < 18);
        updateBirdState(15, 50, isDay); 
        updateDogState(15); 
      }
    });
  </script>
</body>
</html>
