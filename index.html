<!DOCTYPE html>
<html>
<head>
  <title>Room Monitor Dashboard</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Roboto', sans-serif; 
      text-align: center; 
      padding: 20px; 
      background-color: #0a0a23; /* Dark background */
      color: #f0f0f0; /* Light grey text */
    }
    h1 { 
      font-family: 'Orbitron', sans-serif;
      font-size: 28px; /* Slightly larger */
      margin-bottom: 25px; 
      color: #00d0ff; /* Bright blue neon-like color */
      text-shadow: 0 0 6px rgba(0, 208, 255, 0.7); /* Reduced neon glow effect */
    }
    .values {
      font-size: 22px; /* Slightly larger for prominence */
      margin-bottom: 20px;
      color: #e0e0e0; /* Lighter color for labels */
    }
    .values span { /* Targets <span> elements within .values for actual data */
      color: #ffffff; /* White for actual data */
      font-weight: bold;
    }
    /* Timestamp styling - label and value */
    #time-label {
        color: #b0b0b0; /* Softer grey for "Timestamp:" label part */
    }
    #time-value {
        color: #ffffff; /* White for actual data */
        font-weight: bold;
    }
    .charts-container {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    .chart-wrapper {
      max-width: 400px;
      width: 100%;
      background-color: #1c1c3c; /* Darker shade for chart background */
      padding: 15px;
      border-radius: 8px; /* Rounded corners */
      border: 1px solid #00d0ff; /* Subtle border with accent color */
      box-shadow: 0 0 10px rgba(0, 208, 255, 0.3); /* Subtle glow for chart wrappers */
      transition: all 0.3s ease-in-out; /* Smooth transition for hover effects */
    }
    .chart-wrapper:hover {
      box-shadow: 0 0 15px rgba(0, 208, 255, 0.5); /* Enhanced glow on hover */
      transform: scale(1.02); /* Slightly scale up on hover */
    }
    .chart-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      margin-bottom: 10px; /* Increased margin */
      font-size: 20px; /* Larger chart title */
      color: #00d0ff; /* Accent color for chart titles */
    }
    /* Ensure Chart.js canvas elements are not affected by general canvas styling for 3D scene if any */
    .chart-wrapper canvas {
      max-height: 200px !important;
      height: 200px !important;
      width: 100% !important;
      border-radius: 4px; /* Slightly rounded corners for canvas */
    }
    #time-container { /* Container for timestamp label and value */
      font-size: 18px; /* Larger timestamp */
      margin-bottom: 30px;
      display: block;
    }

    /* 3D Scene Container Styles */
    #scene-3d-container {
      width: 80%; 
      max-width: 600px;
      height: 400px; 
      margin: 20px auto;
      border: 1px solid #00d0ff; 
      border-radius: 8px;
      position: relative; 
      background-color: #000000; /* Fallback if canvas doesn't load */
      overflow: hidden; /* Ensures Three.js canvas fits rounded corners */
    }
    #scene-3d-container canvas { /* Style for the Three.js canvas itself */
        display: block; /* Removes any potential extra space below canvas */
    }
  </style>
</head>
<body>
  <h1>üìä Room Monitor</h1>

  <div id="scene-3d-container"></div>

  <div class="values">
    üå° Temperature: <span id="temp">--</span> ¬∞C &nbsp;&nbsp; | &nbsp;&nbsp; üíß Humidity: <span id="hum">--</span> %
  </div>
  <div id="time-container"><span id="time-label">‚è± Timestamp: </span><span id="time-value">--</span></div>

  <div class="charts-container">
    <div class="chart-wrapper">
      <div class="chart-title">Temperature (¬∞C)</div>
      <canvas id="tempChart"></canvas>
    </div>
    <div class="chart-wrapper">
      <div class="chart-title">Humidity (%)</div>
      <canvas id="humChart"></canvas>
    </div>
  </div>

  <script>
    // Firebase and Chart.js setup
    const firebaseConfig = {
      apiKey: "AIzaSyCHCmEo57ty3kLvZRay6BJ8Ie2PjSTnPDg",
      authDomain: "iot-project-baw-pal.firebaseapp.com",
      databaseURL: "https://iot-project-baw-pal-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "iot-project-baw-pal",
      storageBucket: "iot-project-baw-pal.firebasestorage.app",
      messagingSenderId: "845069079178",
      appId: "1:845069079178:web:b877db653292ec2eb79373",
      measurementId: "G-THREY0M483"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let tempData = [];
    let humData = [];
    let labels = [];

    function formatTimestamp(ts) {
      if (!ts) return '--'; 
      return ts.substr(0, 10) + ' ' + ts.substr(11, 8);
    }

    function updateLatest(data) {
      document.getElementById("temp").textContent = data.temperature.toFixed(2);
      document.getElementById("hum").textContent = data.humidity.toFixed(2);
      document.getElementById("time-value").textContent = formatTimestamp(data.timestamp); 
    }

    const ctxTemp = document.getElementById('tempChart').getContext('2d');
    const ctxHum = document.getElementById('humChart').getContext('2d');

    const commonOptions = {
      responsive: true, animation: false,
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45, autoSkip: true, maxTicksLimit: 10, color: '#f0f0f0' }, grid: { color: 'rgba(240, 240, 240, 0.1)' } },
        y: { beginAtZero: false, ticks: { color: '#f0f0f0' }, grid: { color: 'rgba(240, 240, 240, 0.1)' } }
      },
      plugins: { legend: { display: false, labels: { color: '#f0f0f0' } }, tooltip: { mode: 'index', intersect: false, backgroundColor: 'rgba(0, 0, 0, 0.7)', titleColor: '#00d0ff', bodyColor: '#f0f0f0', borderColor: '#00d0ff', borderWidth: 1 } }
    };

    const tempChart = new Chart(ctxTemp, { type: 'line', data: { labels: labels, datasets: [{ label: 'Temperature (¬∞C)', data: tempData, borderColor: '#39ff14', backgroundColor: 'rgba(57, 255, 20, 0.25)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 }] }, options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, suggestedMin: 15, suggestedMax: 40 } } } });
    const humChart = new Chart(ctxHum, { type: 'line', data: { labels: labels, datasets: [{ label: 'Humidity (%)', data: humData, borderColor: '#ff00ff', backgroundColor: 'rgba(255, 0, 255, 0.25)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 }] }, options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, suggestedMin: 20, suggestedMax: 80 } } } });

    // Three.js Scene Setup
    let scene, camera, renderer, requestID;
    let sun3D, moon3D, field3D, tree3DGroup, starField, dog3D; 
    let clouds = []; // Global variable for clouds
    
    function updateSunMoonVisibility(timestamp) {
      let hour;
      if (timestamp) {
        const timePart = timestamp.includes('T') ? timestamp.split('T')[1] : timestamp.split(' ')[1];
        if (timePart) { hour = parseInt(timePart.substr(0, 2)); } else { hour = new Date().getHours(); }
      } else { hour = new Date().getHours(); }

      if (sun3D && moon3D) {
        if (hour >= 6 && hour < 18) { // Daytime
          sun3D.visible = true; 
          moon3D.visible = false; 
          if (scene) scene.background = new THREE.Color(0x87CEEB); // Sky Blue
          if (clouds && clouds.length > 0) clouds.forEach(cloud => cloud.visible = true);
        } else { // Nighttime
          sun3D.visible = false; 
          moon3D.visible = true; 
          if (scene) scene.background = new THREE.Color(0x000000); // Black
          if (clouds && clouds.length > 0) clouds.forEach(cloud => cloud.visible = false);
        }
      }
    }

    function updateDogState(temperature, isDaytime) {
      if (!dog3D || !dog3D.userData.originalMaterialColor) return;
      const dogBodyMesh = dog3D.getObjectByName("dogBody");
      if (!dogBodyMesh) return;

      const activePosition = { x: -1.5, y: -0.5, z: 1 };
      const activeRotation = { x: 0, y: 0, z: 0 };
      
      const sleepingPositionY = -1.0 + (dogBodyMesh.geometry.parameters.width / 2); 
      const sleepingPosition = { x: 0.5, y: sleepingPositionY, z: 0.5 }; 
      const sleepingRotation = { x: 0, y: -Math.PI / 4, z: Math.PI / 2 }; 

      if (isDaytime) {
        dog3D.position.set(activePosition.x, activePosition.y, activePosition.z);
        dog3D.rotation.set(activeRotation.x, activeRotation.y, activeRotation.z);
      } else { 
        dog3D.position.set(sleepingPosition.x, sleepingPosition.y, sleepingPosition.z);
        dog3D.rotation.set(sleepingRotation.x, sleepingRotation.y, sleepingRotation.z);
      }

      if (temperature > 28) { 
        dogBodyMesh.material.color.setHex(0xFF0000); 
      } else { 
        dogBodyMesh.material.color.setHex(dog3D.userData.originalMaterialColor);
      }
    }

    function initThreeJS() {
      const container = document.getElementById('scene-3d-container');
      if (!container) { console.error("3D scene container not found!"); return; }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); 
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      camera = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5); 
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(containerWidth, containerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement); 
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); 
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);
      
      const sunGeometry = new THREE.SphereGeometry(1.0, 32, 32); 
      const sunMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd00, emissive: 0xffdd00, emissiveIntensity: 1 });
      sun3D = new THREE.Mesh(sunGeometry, sunMaterial);
      sun3D.position.set(-5, 4, -6); 
      scene.add(sun3D);

      const moonGeometry = new THREE.SphereGeometry(0.75, 32, 32); 
      const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      moon3D = new THREE.Mesh(moonGeometry, moonMaterial);
      moon3D.position.set(5, 4, -6); 
      scene.add(moon3D);

      const fieldGeometry = new THREE.PlaneGeometry(10, 10);
      const fieldMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
      field3D = new THREE.Mesh(fieldGeometry, fieldMaterial);
      field3D.rotation.x = -Math.PI / 2; 
      field3D.position.y = -1; 
      scene.add(field3D);

      tree3DGroup = new THREE.Group();
      const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 16); 
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk3D = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk3D.position.y = 0; 
      tree3DGroup.add(trunk3D);
      const pineLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x004d00 }); 
      const cone1Geometry = new THREE.ConeGeometry(0.6, 1.0, 16);
      const cone1 = new THREE.Mesh(cone1Geometry, pineLeavesMaterial);
      cone1.position.y = 0.5 + (1.0 / 2); 
      tree3DGroup.add(cone1);
      const cone2Geometry = new THREE.ConeGeometry(0.45, 0.8, 16);
      const cone2 = new THREE.Mesh(cone2Geometry, pineLeavesMaterial);
      cone2.position.y = cone1.position.y + (1.0 / 2) - 0.2; 
      tree3DGroup.add(cone2);
      const localCone3Geometry = new THREE.ConeGeometry(0.3, 0.6, 16);
      const cone3 = new THREE.Mesh(localCone3Geometry, pineLeavesMaterial);
      cone3.position.y = cone2.position.y + (0.8 / 2) - 0.1; 
      tree3DGroup.add(cone3);
      tree3DGroup.position.set(0, -1.0, 0); 
      scene.add(tree3DGroup);
      
      dog3D = new THREE.Group();
      const dogBodyGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.5, 2, 2, 2); 
      const dogBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); 
      const dogBody = new THREE.Mesh(dogBodyGeometry, dogBodyMaterial);
      dogBody.name = "dogBody";
      dog3D.add(dogBody);
      const dogHeadGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3, 2, 2, 2); 
      const dogHeadMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); 
      const dogHead = new THREE.Mesh(dogHeadGeometry, dogHeadMaterial);
      dogHead.name = "dogHead";
      dogHead.position.set(0.35, 0.25, 0); 
      dog3D.add(dogHead);
      const legGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1, 2, 2, 2); 
      const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); 
      const leg1 = new THREE.Mesh(legGeometry, legMaterial); 
      leg1.position.set(0.3, -0.25, 0.15); 
      dog3D.add(leg1);
      const leg2 = new THREE.Mesh(legGeometry, legMaterial.clone()); 
      leg2.position.set(0.3, -0.25, -0.15);
      dog3D.add(leg2);
      const leg3 = new THREE.Mesh(legGeometry, legMaterial.clone()); 
      leg3.position.set(-0.3, -0.25, 0.15);
      dog3D.add(leg3);
      const leg4 = new THREE.Mesh(legGeometry, legMaterial.clone()); 
      leg4.position.set(-0.3, -0.25, -0.15);
      dog3D.add(leg4);
      const earGeometry = new THREE.BoxGeometry(0.05, 0.15, 0.1); 
      const earMaterial = legMaterial.clone(); 
      const leftEar = new THREE.Mesh(earGeometry, earMaterial);
      leftEar.position.set(0, 0.15, 0.1); 
      leftEar.rotation.z = Math.PI / 8;
      dogHead.add(leftEar); 
      const rightEar = new THREE.Mesh(earGeometry, earMaterial.clone());
      rightEar.position.set(0, 0.15, -0.1); 
      rightEar.rotation.z = -Math.PI / 8;
      dogHead.add(rightEar); 
      const tailGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.3);
      const tailMaterial = dogBodyMaterial.clone(); 
      const dogTail = new THREE.Mesh(tailGeometry, tailMaterial);
      dogTail.name = "dogTail";
      dogTail.position.set(-0.45, 0.1, 0); 
      dogTail.rotation.x = -Math.PI / 6; 
      dog3D.add(dogTail);
      dog3D.userData.originalMaterialColor = dogBodyMaterial.color.getHex();
      scene.add(dog3D);

      // Starfield
      const starVertices = [];
      const minDistance = 50; 
      const starCount = 1000;
      for (let i = 0; i < starCount; i++) {
          let x, y, z, dist;
          do {
              x = THREE.MathUtils.randFloatSpread(200); 
              y = THREE.MathUtils.randFloatSpread(200);
              z = THREE.MathUtils.randFloatSpread(200);
              dist = Math.sqrt(x*x + y*y + z*z);
          } while (dist < minDistance);
          starVertices.push(x, y, z);
      }
      const starsGeometry = new THREE.BufferGeometry();
      starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const starsMaterial = new THREE.PointsMaterial({ 
          color: 0xffffff, size: 0.15, sizeAttenuation: true 
      });
      starField = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starField);

      // Clouds
      const cloudTextureBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAABkCAYAAADDhn8LAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAyKADAAQAAAABAAAAZAAAAACfpZ10AAAFJElEQVR4AezaBYLlRhBGYXgBEBBxAREQcRERkP8+073TOzP7MqaEEJnxImbV7K7uqr+qLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA0jSNozCO4ziOIxACAAFECOGcpnlJkqZp2rZtWZbned73fY/neZ7nERTGIAgAy7Isy3me50kSAEAQBEEQBEEQBEHned73fd+2bVuWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWZVmWVVVVX/qgAAAABJRU5ErkJggg==";
      const cloudTexture = new THREE.TextureLoader().load(cloudTextureBase64);
      const cloudMaterial = new THREE.MeshBasicMaterial({ map: cloudTexture, transparent: true, opacity: 0.85, depthWrite: false });
      const cloudGeometry = new THREE.PlaneGeometry(3, 1.5);

      const cloud1 = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud1.position.set(-4, 3.5, -7); 
      cloud1.visible = false;
      clouds.push(cloud1);
      scene.add(cloud1);

      const cloud2 = new THREE.Mesh(cloudGeometry, cloudMaterial.clone()); // Clone material for independent opacity/texture control if needed later
      cloud2.position.set(0, 4.0, -8); 
      cloud2.visible = false;
      clouds.push(cloud2);
      scene.add(cloud2);

      const cloud3 = new THREE.Mesh(cloudGeometry, cloudMaterial.clone());
      cloud3.position.set(5, 3.8, -9); 
      cloud3.visible = false;
      clouds.push(cloud3);
      scene.add(cloud3);
      
      const cloud4 = new THREE.Mesh(cloudGeometry, cloudMaterial.clone());
      cloud4.position.set(-2, 4.2, -6); 
      cloud4.visible = false;
      clouds.push(cloud4);
      scene.add(cloud4);

      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      requestID = requestAnimationFrame(animate);

      // Animate clouds
      if (clouds && clouds.length > 0) {
        clouds.forEach(cloud => {
          if (cloud.visible) { // Only animate visible clouds
            cloud.position.x += 0.003; // Adjust speed as needed
            // Reset cloud position if it moves too far to one side
            if (cloud.position.x > 8) { // Adjust reset boundary as needed
              cloud.position.x = -8; // Reset to the other side
              // Optional: vary Y position slightly when reset for more randomness
              cloud.position.y = 3 + Math.random() * 1.5; 
            }
          }
        });
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const container = document.getElementById('scene-3d-container');
      if (container && camera && renderer) { 
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    }

    function mainAppInit() {
        initThreeJS();
        if (scene && camera && renderer) { 
            animate(); 
            updateSunMoonVisibility(new Date().toISOString()); 
            const currentHour = new Date().getHours();
            const isDay = (currentHour >= 6 && currentHour < 18);
            updateDogState(15, isDay); 
        }
    }

    if (document.readyState === 'loading') { 
        document.addEventListener('DOMContentLoaded', mainAppInit);
    } else { 
        mainAppInit(); 
    }

    const ref = db.ref("smarthome");
    ref.limitToLast(240).on("value", snapshot => {
      tempData = []; humData = []; labels = [];
      snapshot.forEach(childSnap => { const data = childSnap.val(); if (data.temperature != null && data.humidity != null && data.timestamp) { tempData.push(parseFloat(data.temperature)); humData.push(parseFloat(data.humidity)); labels.push(data.timestamp.substr(11, 5)); } });
      tempChart.data.labels = labels; tempChart.data.datasets[0].data = tempData; tempChart.update();
      humChart.data.labels = labels; humChart.data.datasets[0].data = humData; humChart.update();
      
      const last = snapshot.val() ? Object.values(snapshot.val()).pop() : null;
      if (last) { 
        updateLatest(last); 
        const currentTimestamp = last.timestamp ? last.timestamp : new Date().toISOString();
        updateSunMoonVisibility(currentTimestamp);

        let currentHourForDog; 
        if (last.timestamp) {
            const timePart = last.timestamp.includes('T') ? last.timestamp.split('T')[1] : last.timestamp.split(' ')[1];
            if (timePart) currentHourForDog = parseInt(timePart.substr(0, 2));
            else currentHourForDog = new Date().getHours(); 
        } else {
            currentHourForDog = new Date().getHours(); 
        }
        const isDaytimeForDog = (currentHourForDog >= 6 && currentHourForDog < 18); 
        
        const tempForDog = (last.temperature != null) ? parseFloat(last.temperature) : 15; 
        
        if (!isNaN(tempForDog)) {
            updateDogState(tempForDog, isDaytimeForDog); 
        }

      } else { 
        document.getElementById("temp").textContent = '--'; 
        document.getElementById("hum").textContent = '--'; 
        document.getElementById("time-value").textContent = '--'; 
        
        const currentTimestamp = new Date().toISOString();
        updateSunMoonVisibility(currentTimestamp);
        
        const currentHour = new Date().getHours();
        const isDay = (currentHour >= 6 && currentHour < 18);
        updateDogState(15, isDay); 
      }
    });
  </script>
</body>
</html>
